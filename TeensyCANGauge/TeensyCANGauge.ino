/*
* Teensy CAN Gauge
* K.Nason
* 7/29/21
* 
* Useful Examples / Borrowed from:
* https://github.com/Arthris/MSCan_Gauge
* 
* rusEFI CAN Broadcast
* https://github.com/rusefi/rusefi/blob/2ce77778653348a91cc579e3cb6b5df243e2e969/firmware/controllers/can/can_verbose.cpp
* 
* SETUP NOTES
* Setup the CAN base ID and can rate to match the CAN broadcast in Tuner Studio. Found in 'CAN Settings'.
* Setup the display type and pins in 'Display Settings'
*/


// Libraries
//=================================================================================================================================

#include <SPI.h>
#include <Wire.h>
#include <U8g2lib.h>

//Variables / Pins
//================================================================================================================================

// Input button pin
#define btnPin  16
// Total number of gaugels to be cycled
#define lastGauge  5

float sensorValue = 0;
int b = 0;
int g = 0;

// CAN Settings
// =================================================================================================================================

// Setup base ID and rate based on CAN settings
const int baseID = 512;
const int canRate = 500000;

// Use this for Teensy 3.2
#include <FlexCAN.h> 
FlexCAN CANbus(canRate);

// Use this for Teensy 4.0
//#include <FlexCAN_T4.h> 
//FlexCAN_T4<CAN1, RX_SIZE_256, TX_SIZE_16> Can0;

void setupCAN(){
// Use for Teensy 4.0
// Can0.begin();  
// Can0.setBaudRate(canRate);

 // Use for Teensy 3.2
  Can0.begin(canRate); 
}

// Display Settings
//==================================================================================================================================


// SPI SSD1306 128x64
//U8G2_SSD1306_128X64_NONAME_F_4W_SW_SPI u8g2(U8G2_R2, /* clock=*/ 13, /* data=*/ 11, /* cs=*/ 10, /* dc=*/ 9, /* reset=*/ 15);
U8G2_SSD1306_128X64_NONAME_F_4W_HW_SPI u8g2(U8G2_R2,/* cs=*/ 10, /* dc=*/ 9, /* reset=*/ 15);
//I2C
//U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, /* clock=*/ 13, /* data=*/ 11, /* reset=*/ 8);
//U8G2_SSD1306_128X64_ALT0_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

//SPI SH1106 128x64
//U8G2_SH1106_128X64_NONAME_F_4W_SW_SPI u8g2(U8G2_R2, /* clock=*/ 13, /* data=*/ 11, /* cs=*/ 10, /* dc=*/ 9, /* reset=*/ 15);
//U8G2_SH1106_128X64_NONAME_F_4W_HW_SPI u8g2(U8G2_R2, /* cs=*/ 10, /* dc=*/ 9, /* reset=*/ 15);
//I2C
//U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

//Splash Screen
// ==============================================================================================================================

#define splash_width 128
#define splash_height 64
static unsigned char rusEFIsplash[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xe0, 0xee, 0xee, 0x82, 0xdd, 0xdd, 0x8d, 0x0b,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xc3,
   0xff, 0xff, 0x8f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x18, 0x00, 0x00, 0x62, 0x00, 0x00, 0xc8, 0x08, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x22, 0x00, 0x00, 0xc8, 0x08,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x62,
   0x00, 0x00, 0xc8, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x88, 0xff, 0xff, 0x23, 0xfe, 0xff, 0x8f, 0x08, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x98, 0x55, 0x55, 0x61, 0x56, 0x55, 0xc5, 0x08,
   0x00, 0xff, 0xcf, 0x07, 0xc0, 0x07, 0xfc, 0x3f, 0x88, 0x01, 0x00, 0x20,
   0x06, 0x00, 0xc0, 0x08, 0xc0, 0xff, 0xcf, 0x07, 0xc0, 0x87, 0xff, 0x7f,
   0x98, 0x01, 0x00, 0x60, 0x06, 0x00, 0xc0, 0x0c, 0xe0, 0xff, 0xcf, 0x07,
   0xc0, 0x87, 0xff, 0x7f, 0x88, 0x01, 0x00, 0x20, 0x04, 0x00, 0x80, 0x08,
   0xf0, 0xff, 0xdf, 0x07, 0xc0, 0xc7, 0xff, 0x3f, 0x98, 0xdd, 0x5d, 0x60,
   0xde, 0xdd, 0xc1, 0x08, 0xf0, 0xff, 0xcf, 0x07, 0xc0, 0xc7, 0xff, 0x7f,
   0x88, 0xff, 0xff, 0x20, 0xfc, 0xff, 0xc3, 0x08, 0xf0, 0xab, 0xca, 0x07,
   0xc0, 0xc7, 0x57, 0x15, 0x18, 0x00, 0x40, 0x60, 0x00, 0x00, 0xc1, 0x0c,
   0xf0, 0x01, 0xc0, 0x07, 0xc0, 0xc7, 0xff, 0x1f, 0x08, 0x00, 0xc0, 0x20,
   0x00, 0x00, 0x83, 0x08, 0xf8, 0x01, 0xc0, 0x07, 0xc0, 0xc7, 0xff, 0x3f,
   0x18, 0x00, 0x40, 0x60, 0x00, 0x00, 0xc1, 0x08, 0xf0, 0x01, 0xc0, 0x07,
   0xc0, 0xc7, 0xff, 0x7f, 0x88, 0xff, 0xff, 0x20, 0xfe, 0xff, 0xc3, 0x08,
   0xf8, 0x01, 0xc0, 0x07, 0xc0, 0x87, 0xff, 0xff, 0x98, 0x55, 0x05, 0x60,
   0x06, 0x82, 0xc0, 0x0c, 0xf0, 0x01, 0xc0, 0x07, 0xc0, 0x07, 0xff, 0xff,
   0x88, 0x01, 0x00, 0x20, 0x06, 0x00, 0x80, 0x08, 0xf8, 0x01, 0xc0, 0x0f,
   0xc0, 0x07, 0x48, 0xfa, 0x99, 0x01, 0x00, 0x60, 0x06, 0x00, 0xc0, 0x08,
   0xf0, 0x01, 0xc0, 0x0f, 0xc0, 0x07, 0x00, 0xf8, 0x89, 0x01, 0x00, 0x20,
   0x06, 0x00, 0xc0, 0x08, 0xf8, 0x01, 0x80, 0x1f, 0xc0, 0x07, 0x00, 0xf8,
   0x19, 0xb7, 0xdd, 0x62, 0x06, 0x00, 0xc0, 0x0c, 0xf0, 0x01, 0x80, 0xff,
   0xff, 0xc7, 0xff, 0xff, 0x18, 0xfe, 0xff, 0x23, 0x04, 0x00, 0x80, 0x08,
   0xf8, 0x01, 0x80, 0xff, 0xff, 0xc7, 0xff, 0xff, 0x10, 0x00, 0x00, 0x62,
   0x06, 0x00, 0xc0, 0x08, 0xf0, 0x01, 0x00, 0xff, 0xff, 0xc7, 0xff, 0xff,
   0x30, 0x00, 0x00, 0x22, 0x06, 0x00, 0xc0, 0x08, 0xf8, 0x01, 0x00, 0xfe,
   0xff, 0xc7, 0xff, 0x7f, 0xe0, 0x00, 0x00, 0x62, 0x02, 0x00, 0xc0, 0x0c,
   0xf0, 0x01, 0x00, 0xf8, 0xff, 0xc3, 0xff, 0x1f, 0xc0, 0xff, 0xff, 0xe3,
   0x07, 0x00, 0xc0, 0x0f, 0x10, 0x00, 0x00, 0x80, 0x24, 0x01, 0x49, 0x02,
   0x00, 0x24, 0x49, 0x82, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };
   

// =================================================================================================================================

struct DATA {
  String chName;
  int address;
  int sByte;
  int sBit;
  int len;
  float scale;
  String unit;
  float val;
};


  // Base ID + 0
  DATA warningCount = {"Warning Counter",0,0,0,16,1,"#"};
  DATA lastError =  {"Last Error Code",0,2,0,16,1,"#"};
  DATA revLimit =  {"Rev Limit Active",0,4,0,1,1,"On"};
  DATA mainRelay =  {"Main Relay Active",0,4,1,1,1,"On"};
  DATA fuelPump =  {"Fuel Pump Active",0,4,2,1,1,"On"};
  DATA checkEngine = {"Check Engine Active",0,4,3,1,1,"On"};

  // Base ID + 1  
  DATA rpm = {"RPM",1,0,0,16,1,""};
  DATA timing =  {"Timing",1,2,0,16,0.02,"deg"};
  DATA injDuty =  {"Injector Duty",1,4,0,16,0.5,"%"};
  DATA vSpeed =  {"Speed",1,6,0,8,1,"kph"};

  // Base ID + 2
  DATA accelPos = {"Accel Position",2,0,0,16,0.01,"%"};
  DATA tps1 ={"TPS 1",2,2,0,16,0.01,"%"};
  DATA tps2 = {"TPS 2",2,4,0,16,0.01,"%"};

  // Base ID + 3
  DATA mapP ={"MAP",3,0,0,16,0.03,"kPa"};
  DATA clt = {"Coolant",3,2,0,8,1,"C"};
  DATA iat = {"Intake",3,3,0,8,1,"C"};
  DATA aux1 = {"Aux 1",3,4,0,8,1,"C"};
  DATA aux2 = {"Aux 2",3,5,0,8,1,"C"};
  DATA mcu = {"MCU",3,5,0,8,1,"C"};
  DATA fuel ={"Fuel",3,6,0,8,0.5,"%"};
  
  // Base ID + 4
  DATA afr = {"AFR",4,0,0,16,0.001,""};
  DATA oil = {"Oil",4,2,0,16,0.03,"kPa"};
  DATA vvt = {"VVT",4,4,0,16,0.02,"deg"};
  DATA battery = {"Battery",4,6,0,16,0.001,"V"};

  // Base ID + 5
  DATA airMass = {"Air Mass",5,0,0,16,1,"mg"};
  DATA airFlow = {"Air Flow",5,2,0,16,0.01,"kg/h"};
  DATA injPw = {"Inj Pw",5,4,0,16,0.003,"ms"};

// Functions
// ================================================================================================================================================

 // Check the message ID and update sensor values contained in the message
void setupSensorData(CAN_message_t inMsg){
  switch (inMsg.id){

      case (baseID + 1):
        rpm.val = getSensorData2(inMsg,rpm);
        timing.val = getSensorData2(inMsg,timing);
        injDuty.val = getSensorData2(inMsg,injDuty);
        vSpeed.val = getSensorData2(inMsg,vSpeed);
        break;
        
      case (baseID + 2):
        accelPos.val = getSensorData2(inMsg,accelPos);
        tps1.val = getSensorData2(inMsg,tps1);
        tps2.val = getSensorData2(inMsg,tps2);
        break;
        
      case (baseID + 3):
         mapP.val = getSensorData2(inMsg,mapP);
         clt.val = getSensorData2(inMsg,clt);
         iat.val = getSensorData2(inMsg,iat);
         aux1.val = getSensorData2(inMsg,aux1);
         aux2.val = getSensorData2(inMsg,aux2);
         mcu.val = getSensorData2(inMsg,mcu);
         fuel.val = getSensorData2(inMsg,fuel);
        break;
        
      case (baseID + 4):
          afr.val = getSensorData2(inMsg,afr);
          oil.val = getSensorData2(inMsg,oil);
         vvt.val = getSensorData2(inMsg,vvt);
          battery.val = getSensorData2(inMsg,battery);
        break;
        
      case (baseID + 5):
          airMass.val = getSensorData2(inMsg,airMass);
          airFlow.val = getSensorData2(inMsg,airFlow);
          injPw.val = getSensorData2(inMsg,injPw);
        break;
    }  
}

void buttonPress(){
  b = 1;
}

// Print text of a defined size and location in pixels

void printText(String text, int textSize, int locX, int locY){
   char t[100];
   text.toCharArray(t,100);        
   u8g2.setColorIndex(1);
   u8g2.setFont(u8g2_font_8x13B_tf);
   u8g2.drawStr(locX, locY, t); 
                                 
}

void showSplash(){
  u8g2.clearBuffer();
  u8g2.drawXBMP(0,0,splash_width,splash_height, rusEFIsplash);
  u8g2.sendBuffer();
}

// Display the CAN rate in kbps and Base ID setting
void showSettings(){
  u8g2.clearBuffer();
  printText("CAN",0,0,15);
  printText("rate " + String(canRate/1000) + "k",0,0,40);
  printText("base " + String(baseID),0,0,60);
  u8g2.sendBuffer();
}
// Sets up a single sensor value for the display, still requires updating the display
void printSensor1(struct DATA &channel){
    printText(channel.chName,1,0,10);
    printText(String(channel.val),3,0,40);
       
}

// Sets up two sensor values for the display, still requires updating the display
void printSensor2(struct DATA &channel, struct DATA &channel2){
  
    printText(channel.chName,1,0,10);
    printText(String(channel.val),3,60,25); 
    printText(channel2.chName,1,0,45);
    printText(String(channel2.val),3,60,60);
 
}


float getSensorData2(CAN_message_t CANmsg, struct DATA &channel){

  // Check the data length in bits (1 to 2 bytes) and grab that many from the starting byte location
  if (channel.len == 8){
    channel.val = (int)CANmsg.buf[channel.sByte];  
  }
  else if (channel.len == 16){
    sensorValue = (int)(word(CANmsg.buf[channel.sByte+1],CANmsg.buf[channel.sByte])); 
  }
  else {
    sensorValue = 0;
  }

  // Apply data scaling
  sensorValue = sensorValue * channel.scale;
  return sensorValue;
}


// MAIN
//==================================================================================================================================


void setup(){
  //Serial.begin(9600);
  // Setup interrupt for input button, setup to use a normally open button to pull input pin low on press
  pinMode(btnPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(btnPin),buttonPress,LOW);

  
  setupCAN();
  
//  // Start the display
//  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
//   for(;;);
//  }
//
//  display.begin(SSD1306_SWITCHCAPVCC);
//  u8g2_for_adafruit_gfx.begin(display);

  u8g2.begin();   

  u8g2.setColorIndex(1);
  u8g2.setFont(u8g2_font_6x10_tf);
  
  showSplash();
  delay(3000);

  showSettings();
  delay(2500);

// print message to the display, it will remain until data is recieved
  
  u8g2.clearBuffer();
  printText(("Waiting for Data"),1,0,10);
  printText(("..."),1,55,40);
  u8g2.sendBuffer();

//delay(1000);
  
}

void loop(){
  CAN_message_t inMsg;

 // Only update the display when a CAN message is recieved 
  if ( Can0.available() ) {
    Can0.read(inMsg);
  // Update values contained in the reieved message
    setupSensorData(inMsg);  
    
    switch (g){
    case 0:
      printSensor1(afr);
      break;
    case 1:
      printSensor1(rpm);
      break;
    case 2:
      printSensor2(clt,iat);
      break;
    case 3:
      printSensor2(iat,mapP);
      break;
    case 4:
      printSensor2(rpm,afr);
      break;
    case 5:
      printSensor1(battery);
      break;
    }
    // Update the display with the selected sensor value
    u8g2.sendBuffer();
    u8g2.clearBuffer();
  }

  

     
    // Cycle to the next gauge/sensor if the button was pressed
    if (b==1){
      b=0;
      g++;
      if (g>lastGauge){
        g=0;
       }
    }
}
